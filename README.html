<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="experimenten-deeplearning-convolutional-layers-op-fashion-mnist" class="level1">
<h1>Experimenten deeplearning convolutional layers op Fashion MNIST</h1>
<p>Geef in settings.py aan welke combinaties je wilt uitproberen. De modellen bouw je op in het bestand settings_testmodels.py</p>
<pre><code>    experiment_parameters_combinations: Dict = {
        'trainloop.optimizer' : {
            'AdamW' : optim.AdamW,
            'SGD' : optim.SGD,
            'RMSprop' : optim.RMSprop,
            'Adam' : optim.Adam
        },
        'trainloop.learning_rate' : {
            'LR-1E-2' : 0.01,
            'LR-1E-3' : 0.001,
            'LR-1E-4' : 0.0001,
        },
        'models' : {
            'model1' : 'model1',
            'model2' : 'model2',
            'model3' : 'model3',
        }
    }</code></pre>
<p>De drie verschillende modellen bestaan uit:</p>
<p><strong>model 1</strong></p>
<ul>
<li>3 convolution lagen</li>
<li>16 filters / activation maps</li>
<li>2 dense lagen</li>
</ul>
<p><strong>model 2</strong></p>
<ul>
<li>3 convolution lagen</li>
<li>32 filters / activation maps</li>
<li>3 dense lagen</li>
</ul>
<p><strong>model 3</strong></p>
<ul>
<li>3 convolution lagen</li>
<li>128 filters / activation maps</li>
<li>5 dense lagen</li>
</ul>
<p><strong>model ResNet18</strong></p>
<ul>
<li>1 convolution laag</li>
<li>8 Res blokken met 2 convolution</li>
<li>512 filters</li>
</ul>
<p>Run hierna autmatisch alle combinaties. Resultaten worden in de log map geplaatst.</p>
<p><code>$poetry run python main.py --task=combine --name=mijn_eigen_experiment_naam</code></p>
<p>De best scorende resultaten kan je verder testen door in de settings op te geven welke je wilt runnen.</p>
<pre><code>    experiments_runs: Dict = {
        'run1' : {
            'epochs' : 20,
            'run_name' : 'Adam_LR-1E-3_model3',
            'optimizer' : optim.Adam,
            'learning_rate' : 0.001,
            'model' : 'model3',
        },
        'run2' : {
            'epochs' : 20,
            'run_name' : 'RMSprop_LR-1E-3_model3',
            'optimizer' : optim.RMSprop,
            'learning_rate' : 0.001,
            'model' : 'model3',
        },
        'run3' : {
            'epochs' : 20,
            'run_name' : 'AdamW_LR-1E-3_model3',
            'optimizer' : optim.AdamW,
            'learning_rate' : 0.001,
            'model' : 'model3',
        }
    }</code></pre>
<p>Start de runs met onderstaand commando:</p>
<p><code>$poetry run python main.py --task=runs --name=mijn_eigen_experiment_naam</code></p>
</section>
<section id="resultaten" class="level1">
<h1>Resultaten</h1>
<p>Hieronder de best scorende resultaten van alle combinaties.</p>
<p>Adam 1e-3 model 3 RMSprop 1e-3 model 3 AdamW 1e-3 model 3</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/combine_results2.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Top 4 combined results</figcaption><p></p>
</figure>
</div>
<p>Over het algemeen scoren de runs met optimizer SGD niet goed. Opmerkelijk is dat het er op lijkt dat optimizer SGD beter werkt met een hoge learning rate en een simpel model.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/combine_SGD_remarks.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">SDG remarks</figcaption><p></p>
</figure>
</div>
<p>Je ziet hieronder dat na epoch 9 het model gaat overfitten. AdamW geeft hier de hoogste loss in de test set.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/runs_loss_test_loss_train.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">loss test en loss train</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/runs_accuracy.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">runs accuuracy</figcaption><p></p>
</figure>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>